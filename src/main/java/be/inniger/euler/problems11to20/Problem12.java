package be.inniger.euler.problems11to20;

import be.inniger.euler.util.Math;
import be.inniger.euler.value.FactorizedInteger;
import be.inniger.euler.value.FactorizedInteger.Factor;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.IntStream;

import static be.inniger.euler.util.Math.isEven;

/**
 * Highly divisible triangular number
 * <p>
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * Let us list the factors of the first seven triangle numbers:
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 * What is the value of the first triangle number to have over five hundred divisors?
 */
public class Problem12 {

  private static final int MINIMUM_NR_DIVISORS = 500 + 1;
  private final Map<Integer, Integer> nrDivisorsCache = new HashMap<>();

  public int solve() {
    return IntStream.iterate(1, Math::inc)
        .dropWhile(n -> getNrDivisorsOfNthTriangle(n) < MINIMUM_NR_DIVISORS)
        .map(this::getNthTriangle)
        .findFirst()
        .orElseThrow();
  }

  /*
   * If "t" is the "n-th" triangle number the following relationship holds, on account of n and n+1 being always co-prime
   *
   * D(t) = D(n/2) * D(n+1)     -- if n   is even
   * D(t) = D(n)   * D((n+1)/2) -- if n+1 is even
   */
  private int getNrDivisorsOfNthTriangle(int n) {
    return isEven(n) ?
        getNrDivisors(n / 2) * getNrDivisors(n + 1) :
        getNrDivisors(n) * getNrDivisors((n + 1) / 2);
  }

  private int getNrDivisors(int number) {
    return nrDivisorsCache.computeIfAbsent(number, __ ->
        FactorizedInteger.valueOf(number)
            .getFactors()
            .map(Factor::getExponent)
            .mapToInt(Math::inc)
            .reduce(1, Math::multiply));
  }

  private int getNthTriangle(int n) {
    return (n + 1) * n / 2;
  }
}
